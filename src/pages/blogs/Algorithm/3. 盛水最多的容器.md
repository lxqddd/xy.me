# 解题思路

> 盛最多水的容器，可以理解为计算矩形的面积，矩形的高为数组中给定的数据，矩形的宽为两个高度之间的距离

## 第一种思路

> 时间复杂度和空间复杂度都较高，理解起来相对容易

1. 记录两个游标 i 和 j
2. i 和 j 分别对应不同的高度，而矩形的高度应该是两个高度之中较小的哪一个，因为要盛水~
3. 矩形的宽度是 i 和 j 的差值
4. 现在宽和高都已经定义好了，那我们就可以去计算矩形的面积了，不就是 `长 * 宽` 嘛

```javascript
var maxArea = function (height) {
  let area = 0
  let temp = 0
  for (let i = 0; i <= height.length - 2; i++) {
    for (let j = i + 1; j <= height.length - 1; j++) {
      if (height[i] > height[j]) {
        temp = height[j] * (j - i)
      } else {
        temp = height[i] * (j - i)
      }
      if (temp > area) area = temp
    }
  }
  return area
}
```

### 代码解读

1. 定义两个变量，area 和 temp，分别代表最大面积和一个临时面积
2. 开始循环
   1. 按顺序取高度
   2. 第一层循环，表示第一个高度
   3. 长度减 2，表示 i 最多只能取到倒数第二个值
   4. 第二层循环，表示第二个高度
   5. 长度减 1 表示 j 可以取到最后一个值，这也是为什么 i 要减 2 的原因
3. 再循环中对两个高度进行比较，取出其中较小的一个和宽度相乘（宽度其实就是两个游标之间的距离，也就是 j - i）
4. 比较 area 和 temp 的值，将较大的一个作为当前矩形的面积，然后进行下一轮循环

这种解法虽然能够解决问题，但是因为用了双重循环，所以时间复杂度太高

## 第二种方法

思路其实跟第一种解法差不多，只是游标的定义不太一样，我们直接看代码叭

```javascript
var maxArea = function (height) {
  let area = 0
  let i = 0
  let j = height.length - 1

  for (i; i < j; ) {
    const minHeight = height[i] > height[j] ? height[j--] : height[i++]
    const temp = minHeight * (j - i + 1)
    area = Math.max(area, temp)
  }
  return area
}
```

### 代码解读

1. 首先还是要定义 area 作为最终面积的存储空间
2. 定义两个指针 i 和 j
   1. 这里就和第一种方式不一样了，第一种方式定义的时候是两个指针统一从左向右移动
   2. 这里定义的两个指针分别指向第一个元素和最后一个元素
3. 开始循环，循环的起点是数组中的第一个元素，当两个指针相遇时结束循环
4. 获取到两个高度中较小的一个，然后移动游标
   1. 如果左指针对应的高度比右指针对应的高度大
   2. 那就向内（向左）移动右指针
   3. 如果右指针对应的高度比左指针对应的高度大
   4. 那就向内（向右）移动左指针
   5. 为什么总是移动较小的哪一个呢？
   6. 因为如果移动较大的哪一个指针，那么移动之后的面积一定比当前的面积小
      1. 这里再稍微详细的解释一下
      2. 比如说现在 i 指向的高度是 2，j 指向的高度是 8，i 和 j 之间的距离是 6
      3. 那么这个时候的面积是 `2 * 6 = 12`
      4. 如果移动的是 j，那不管移动的结果如何，哪怕 j 指向的高度比 8 更大，新的面积也只会比 12 更小
      5. 因为移动之后较小的高度是不变的，而 i 和 j 之间的距离变小了，所以 面积也是更小的
      6. 这就是要移动指向较小高度的指针的原因
5. 指针移动之后，求一个临时面积 temp，这里在计算宽度的时候需要在 `j - i` 的基础上加 1，因为这里的 i 和 j 对应的是数组的下表，所以会比实际的宽度小 1
6. 比较临时面积 temp 和 area，将较大的那一个作为最终面积
